<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>a-chat tutorial</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>a-chat tutorial</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this tutorial, we will implement an asynchronous chat on top of async-std.</p>
</div>
<div class="paragraph">
<p><a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/async-rs/a-chat/gh-pages/index.html">HTML version</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_specification">Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The chat uses a simple text protocol over TCP.
The protocol consists of utf-8 messages, separated by <code>\n</code>.</p>
</div>
<div class="paragraph">
<p>The client connects to the server and sends login as a first line.
After that, the client can send messages to other clients using the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">login1, login2, ... login2: message</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of the specified clients than receives a <code>from login: message</code> message.</p>
</div>
<div class="paragraph">
<p>A possible session might look like this</p>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">alice</div>
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">&gt; alice
&gt; bob: hello


&lt; from bob: hi!</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">bob</div>
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">&gt; bob

&lt; from alice: hello
&gt; alice, bob: hi!
&lt; from bob: hi!</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The main challenge for the chat server is keeping track of many concurrent connections.
The main challenge for the chat client is managing concurrent outgoing messages, incoming messages and user&#8217;s typing.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started">Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s create a new Cargo project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">$ cargo new a-chat
$ cd a-chat</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the following to your <code>Cargo.toml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">futures-preview = { version = "0.3.0-alpha.18", features = [ "async-await", "nightly" ] }
async-std = "0.99"</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the moment <code>async-std</code> requires nightly, so let&#8217;s add a rustup override for convenience:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">$ rustup override add nightly
$ rustc --version
rustc 1.38.0-nightly (c4715198b 2019-08-05)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_accept_loop">Accept Loop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s implement the scaffold of the server: a loop that binds a TCP socket to an address and starts accepting connections.</p>
</div>
<div class="paragraph">
<p>First of all, let&#8217;s add required import boilerplate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::net::ToSocketAddrs; <i class="conum" data-value="1"></i><b>(1)</b>

use async_std::{
    prelude::*, <i class="conum" data-value="2"></i><b>(2)</b>
    task,       <i class="conum" data-value="3"></i><b>(3)</b>
    net::TcpListener, <i class="conum" data-value="4"></i><b>(4)</b>
};

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt<i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>async_std</code> uses <code>std</code> types where appropriate.
We&#8217;ll need <code>ToSocketAddrs</code> to specify address to listen on.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>prelude</code> re-exports some traits required to work with futures and streams</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>task</code> module roughtly corresponds to <code>std::thread</code> module, but tasks are much lighter weight.
A single thread can run many tasks.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>For the socket type, we use <code>TcpListener</code> from <code>async_std</code>, which is just like <code>std::net::TcpListener</code>, but is non-blocking and uses <code>async</code> API.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We will skip implementing comprehensive error handling in this example.
To propagate the errors, we will use a boxed error trait object.
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do you know that there&#8217;s <code>From&lt;&amp;'_ str&gt; for Box&lt;dyn Error&gt;</code> implementation in
      stdlib, which allows you to use strings with <code>?</code> operator?
</td>
</tr>
</table>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can write the server&#8217;s accept loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">async fn server(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    let listener = TcpListener::bind(addr).await?; <i class="conum" data-value="2"></i><b>(2)</b>
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await { <i class="conum" data-value="3"></i><b>(3)</b>
        // TODO
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We mark <code>server</code> function as <code>async</code>, which allows us to use <code>.await</code> syntax inside.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>TcpListener::bind</code> call returns a future, which we <code>.await</code> to extract the <code>Result</code>, and then <code>?</code> to get a <code>TcpListener</code>.
Note how <code>.await</code> and <code>?</code> work nicely together.
This is exactly how <code>std::net::TcpListener</code> works, but with <code>.await</code> added.
Mirroring API of <code>std</code> is an explicit design goal of <code>async_std</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here, we would like to iterate incoming sockets, just how one would do in <code>std</code>:
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">let listener: std::net::TcpListener = unimplemented!();
for stream in listener.incoming() {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately this doesn&#8217;t quite work with <code>async</code> yet, because there&#8217;s no support for <code>async</code> for-loops in the language yet.
For this reason we have to implement the loop manually, by using <code>while let Some(item) = iter.next().await</code> pattern.</p>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s add main:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">fn main() -&gt; Result&lt;()&gt; {
    let fut = server("127.0.0.1:8080");
    task::block_on(fut)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The crucial thing to realise that is in Rust, unlike other languages, calling an async function does <strong>not</strong> run any code.
Async functions only construct futures, which are inert state machines.
To start stepping through the future state-machine in an async function, you should use <code>.await</code>.
In a non-async function, a way to execute a future is to handle it to the executor.
In this case, we use <code>task::block_on</code> to execute future on the current thread and block until it&#8217;s done.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_receiving_messages">Receiving messages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s implement the receiving part of the protocol.
We need to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>split incoming <code>TcpStream</code> on <code>\n</code> and decode bytes as utf-8</p>
</li>
<li>
<p>interpret the first line as a login</p>
</li>
<li>
<p>parse the rest of the lines as a  <code>login: message</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use async_std::net::TcpStream;

async fn server(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
    let listener = TcpListener::bind(addr).await?;
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!("Accepting from: {}", stream.peer_addr()?);
        let _handle = task::spawn(client(stream)); <i class="conum" data-value="1"></i><b>(1)</b>
    }
    Ok(())
}

async fn client(stream: TcpStream) -&gt; Result&lt;()&gt; {
    let reader = BufReader::new(&amp;stream); <i class="conum" data-value="2"></i><b>(2)</b>
    let mut lines = reader.lines();

    let name = match lines.next().await { <i class="conum" data-value="3"></i><b>(3)</b>
        None =&gt; Err("peer disconnected immediately")?,
        Some(line) =&gt; line?,
    };
    println!("name = {}", name);

    while let Some(line) = lines.next().await { <i class="conum" data-value="4"></i><b>(4)</b>
        let line = line?;
        let (dest, msg) = match line.find(':') { <i class="conum" data-value="5"></i><b>(5)</b>
            None =&gt; continue,
            Some(idx) =&gt; (&amp;line[..idx], line[idx + 1 ..].trim()),
        };
        let dest: Vec&lt;String&gt; = dest.split(',').map(|name| name.trim().to_string()).collect();
        let msg: String = msg.trim().to_string();
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use <code>task::spawn</code> function to spawn an independent task for working with each client.
That is, after accepting the client the <code>server</code> loop immediately starts waiting for the next one.
This is the core benefit of event-driven architecture: we serve many number of clients concurrently, without spending many hardware threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Luckily, the "split byte stream into lines" functionality is already implemented.
<code>.lines()</code> call returns a stream of <code>String</code>'s.
TODO: show how one would implement <code>lines</code> by hand?</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We get the first line&#8201;&#8212;&#8201;login</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>And, once again, we implement a manual async for loop.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finally, we parse each line into a list of destination logins and the message itself.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_managing_errors">Managing Errors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One serious problem in the above solution is that, while we correctly propagate errors in the <code>client</code>, we just drop the error on the floor afterwards!
That is, <code>task::spawn</code> does not return error immediately (it can&#8217;t, it needs to run the future to completion first), only after it is joined.
We can "fix" it by waiting for the task to be joined, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">let handle = task::spawn(client(stream)); <i class="conum" data-value="1"></i><b>(1)</b>
handle.await?</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.await</code> waits until the client finishes, and <code>?</code> propagates the result.</p>
</div>
<div class="paragraph">
<p>There are two problems with this solution however!
<em>First</em>, because we immediately await the client, we can only handle one client at time, and that completely defeats the purpose of async!
<em>Second</em>, if a client encounters an IO error, the whole server immediately exits.
That is, a flaky internet connection of one peer brings down the whole chat room!</p>
</div>
<div class="paragraph">
<p>A correct way to handle client errors in this case is log them, and continue serving other clients.
So let&#8217;s use a helper function for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">fn spawn_and_log_error&lt;F&gt;(fut: F) -&gt; task::JoinHandle&lt;()&gt;
where
    F: Future&lt;Output = Result&lt;()&gt;&gt; + Send + 'static,
{
    task::spawn(async move {
        if let Err(e) = fut.await {
            eprintln!("{}", e)
        }
    })
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sending_messages">Sending Messages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now it&#8217;s time to implement the other half&#8201;&#8212;&#8201;sending messages.
A most obvious way to implement sending is to give each <code>client</code> access to the write half of <code>TcpStream</code> of each other clients.
That way, a client can directly <code>.write_all</code> a message to recipients.
However, this would be wrong: if Alice sends <code>bob: foo</code>, and Charley sends <code>bob: bar</code>, Bob might actually receive <code>fobaor</code>.
Sending a message over a socket might require several syscalls, so two concurrent <code>.write_all</code>'s might interfere with each other!</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, only a single task should write to each <code>TcpStream</code>.
So let&#8217;s create a <code>client_writer</code> task which receives messages over a channel and writes them to the socket.
This task would be the point of serialization of messages.
if Alice and Charley send two messages to Bob at the same time, Bob will see the messages in the same order as they arrive in the channel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use futures::channel::mpsc; <i class="conum" data-value="1"></i><b>(1)</b>
use futures::SinkExt;

type Sender&lt;T&gt; = mpsc::UnboundedSender&lt;T&gt<i class="conum" data-value="2"></i><b>(2)</b>
type Receiver&lt;T&gt; = mpsc::UnboundedReceiver&lt;T&gt;;

async fn client_writer(
    mut messages: Receiver&lt;String&gt;,
    stream: Arc&lt;TcpStream&gt;, <i class="conum" data-value="3"></i><b>(3)</b>
) -&gt; Result&lt;()&gt; {
    let mut stream = &amp;*stream;
    while let Some(msg) = messages.next().await {
        stream.write_all(msg.as_bytes()).await?;
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We will use channels from the <code>futures</code> crate.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For simplicity, we will use <code>unbounded</code> channels, and won&#8217;t be discussing backpressure in this tutorial.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>As <code>client</code> and <code>client_writer</code> share the same <code>TcpStream</code>, we need to put it into an <code>Arc</code>.
Note that because <code>client</code> only reads from and <code>client_writer</code> only writes to the stream, so we don&#8217;t get a race here.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_connecting_readers_and_writers">Connecting Readers and Writers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So how we make sure that messages read in <code>client</code> flow into the relevant <code>client_writer</code>?
We should somehow maintain an <code>peers: HashMap&lt;String, Sender&lt;String&gt;&gt;</code> map which allows a client to find destination channels.
However, this map would be a bit of shared mutable state, so we&#8217;ll have to wrap an <code>RwLock</code> over it and answer tough questions of what should happen if the client joins at the same moment as it receives a message.</p>
</div>
<div class="paragraph">
<p>One trick to make reasoning about state simpler comes from the actor model.
We can create a dedicated broker tasks which owns the <code>peers</code> map and communicates with other tasks by channels.
By hiding <code>peers</code> inside such "actor" task, we remove the need for mutxes and also make serialization point explicit.
The order of events "Bob sends message to Alice" and "Alice joins" is determined by the order of the corresponding events in the broker&#8217;s event queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">#[derive(Debug)]
enum Event { <i class="conum" data-value="1"></i><b>(1)</b>
    NewPeer {
        name: String,
        stream: Arc&lt;TcpStream&gt;,
    },
    Message {
        from: String,
        to: Vec&lt;String&gt;,
        msg: String,
    },
}

async fn broker(mut events: Receiver&lt;Event&gt;) -&gt; Result&lt;()&gt; {
    let mut peers: HashMap&lt;String, Sender&lt;String&gt;&gt; = HashMap::new(); <i class="conum" data-value="2"></i><b>(2)</b>

    while let Some(event) = events.next().await {
        match event {
            Event::Message { from, to, msg } =&gt; {  <i class="conum" data-value="3"></i><b>(3)</b>
                for addr in to {
                    if let Some(peer) = peers.get_mut(&amp;addr) {
                        peer.send(format!("from {}: {}\n", from, msg)).await?
                    }
                }
            }
            Event::NewPeer { name, stream } =&gt; {
                match peers.entry(name) {
                    Entry::Occupied(..) =&gt; (),
                    Entry::Vacant(entry) =&gt; {
                        let (client_sender, client_receiver) = mpsc::unbounded();
                        entry.insert(client_sender); <i class="conum" data-value="4"></i><b>(4)</b>
                        spawn_and_log_error(client_writer(client_receiver, stream)); <i class="conum" data-value="5"></i><b>(5)</b>
                    }
                }
            }
        }
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Broker should handle two types of events: a message or an arrival of a new peer.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Internal state of the broker is a <code>HashMap</code>.
Note how we don&#8217;t need a <code>Mutex</code> here and can confidently say, at each iteration of the broker&#8217;s loop, what is the current set of peers</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To handle a message we send it over a channel to each destination</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>To handle new peer, we first register it in the peer&#8217;s map &#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203; and then spawn a dedicated task to actually write the messages to the socket.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_all_together">All Together</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At this point, we only need to start broker to get a fully-functioning (in the happy case!) chat:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::{
    net::ToSocketAddrs,
    sync::Arc,
    collections::hash_map::{HashMap, Entry},
};

use futures::{
    channel::mpsc,
    SinkExt,
};

use async_std::{
    io::BufReader,
    prelude::*,
    task,
    net::{TcpListener, TcpStream},
};

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
type Sender&lt;T&gt; = mpsc::UnboundedSender&lt;T&gt;;
type Receiver&lt;T&gt; = mpsc::UnboundedReceiver&lt;T&gt;;


fn main() -&gt; Result&lt;()&gt; {
    task::block_on(server("127.0.0.1:8080"))
}

async fn server(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
    let listener = TcpListener::bind(addr).await?;

    let (broker_sender, broker_receiver) = mpsc::unbounded(); <i class="conum" data-value="1"></i><b>(1)</b>
    let _broker_handle = task::spawn(broker(broker_receiver));
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!("Accepting from: {}", stream.peer_addr()?);
        spawn_and_log_error(client(broker_sender.clone(), stream));
    }
    Ok(())
}

async fn client(mut broker: Sender&lt;Event&gt;, stream: TcpStream) -&gt; Result&lt;()&gt; {
    let stream = Arc::new(stream); <i class="conum" data-value="2"></i><b>(2)</b>
    let reader = BufReader::new(&amp;*stream);
    let mut lines = reader.lines();

    let name = match lines.next().await {
        None =&gt; Err("peer disconnected immediately")?,
        Some(line) =&gt; line?,
    };
    broker.send(Event::NewPeer { name: name.clone(), stream: Arc::clone(&amp;stream) }).await <i class="conum" data-value="3"></i><b>(3)</b>
        .unwrap();

    while let Some(line) = lines.next().await {
        let line = line?;
        let (dest, msg) = match line.find(':') {
            None =&gt; continue,
            Some(idx) =&gt; (&amp;line[..idx], line[idx + 1 ..].trim()),
        };
        let dest: Vec&lt;String&gt; = dest.split(',').map(|name| name.trim().to_string()).collect();
        let msg: String = msg.trim().to_string();

        broker.send(Event::Message { <i class="conum" data-value="4"></i><b>(4)</b>
            from: name.clone(),
            to: dest,
            msg,
        }).await.unwrap();
    }
    Ok(())
}

async fn client_writer(
    mut messages: Receiver&lt;String&gt;,
    stream: Arc&lt;TcpStream&gt;,
) -&gt; Result&lt;()&gt; {
    let mut stream = &amp;*stream;
    while let Some(msg) = messages.next().await {
        stream.write_all(msg.as_bytes()).await?;
    }
    Ok(())
}

#[derive(Debug)]
enum Event {
    NewPeer {
        name: String,
        stream: Arc&lt;TcpStream&gt;,
    },
    Message {
        from: String,
        to: Vec&lt;String&gt;,
        msg: String,
    },
}

async fn broker(mut events: Receiver&lt;Event&gt;) -&gt; Result&lt;()&gt; {
    let mut peers: HashMap&lt;String, Sender&lt;String&gt;&gt; = HashMap::new();

    while let Some(event) = events.next().await {
        match event {
            Event::Message { from, to, msg } =&gt; {
                for addr in to {
                    if let Some(peer) = peers.get_mut(&amp;addr) {
                        peer.send(format!("from {}: {}\n", from, msg)).await?
                    }
                }
            }
            Event::NewPeer { name, stream} =&gt; {
                match peers.entry(name) {
                    Entry::Occupied(..) =&gt; (),
                    Entry::Vacant(entry) =&gt; {
                        let (client_sender, client_receiver) = mpsc::unbounded();
                        entry.insert(client_sender); <i class="conum" data-value="4"></i><b>(4)</b>
                        spawn_and_log_error(client_writer(client_receiver, stream)); <i class="conum" data-value="5"></i><b>(5)</b>
                    }
                }
            }
        }
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inside the <code>server</code>, we create broker&#8217;s channel and <code>task</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inside <code>client</code>, we need to wrap <code>TcpStream</code> into an <code>Arc</code>, to be able to share it with the <code>client_writer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>On login, we notify the broker.
Note that we <code>.unwrap</code> on send: broker should outlive all the clients and if that&#8217;s not the case the broker probably panicked, so we can escalate the panic as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Similarly, we forward parsed messages to the broker, assuming that it is alive.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clean_shutdown">Clean Shutdown</h2>
<div class="sectionbody">
<div class="paragraph">
<p>On of the problems of the current implementation is that it doesn&#8217;t handle graceful shutdown.
If we break from the accept loop for some reason, all in-flight tasks are just dropped on the floor.
A more correct shutdown sequence would be:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Stop accepting new clients</p>
</li>
<li>
<p>Deliver all pending messages</p>
</li>
<li>
<p>Exit the process</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A clean shutdown in a channel based architecture is easy, although it can appear a magic trick at first.
In Rust, receiver side of a channel is closed as soon as all senders are dropped.
That is, as soon as producers exit and drop their senders, the rest of the system shutdowns naturally.
In <code>async_std</code> this translates to two rules:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure that channels form an acyclic graph.</p>
</li>
<li>
<p>Take care to wait, in the correct order, until intermediate layers of the system process pending messages.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In <code>a-chat</code>, we already have an unidirectional flow of messages: <code>reader &#8594; broker &#8594; writer</code>.
However, we never wait for broker and writers, which might cause some messages to get dropped.
Let&#8217;s add waiting to the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">async fn server(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
    let listener = TcpListener::bind(addr).await?;

    let (broker_sender, broker_receiver) = mpsc::unbounded();
    let broker = task::spawn(broker(broker_receiver));
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!("Accepting from: {}", stream.peer_addr()?);
        spawn_and_log_error(client(broker_sender.clone(), stream));
    }
    drop(broker_sender); <i class="conum" data-value="1"></i><b>(1)</b>
    broker.await?; <i class="conum" data-value="5"></i><b>(5)</b>
    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And to the broker:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">async fn broker(mut events: Receiver&lt;Event&gt;) -&gt; Result&lt;()&gt; {
    let mut writers = Vec::new();
    let mut peers: HashMap&lt;String, Sender&lt;String&gt;&gt; = HashMap::new();

    while let Some(event) = events.next().await { <i class="conum" data-value="2"></i><b>(2)</b>
        match event {
            Event::Message { from, to, msg } =&gt; {
                for addr in to {
                    if let Some(peer) = peers.get_mut(&amp;addr) {
                        peer.send(format!("from {}: {}\n", from, msg)).await?
                    }
                }
            }
            Event::NewPeer { name, stream} =&gt; {
                match peers.entry(name) {
                    Entry::Occupied(..) =&gt; (),
                    Entry::Vacant(entry) =&gt; {
                        let (client_sender, client_receiver) = mpsc::unbounded();
                        entry.insert(client_sender);
                        let handle = spawn_and_log_error(client_writer(client_receiver, stream));
                        writers.push(handle); <i class="conum" data-value="4"></i><b>(4)</b>
                    }
                }
            }
        }
    }
    drop(peers); <i class="conum" data-value="3"></i><b>(3)</b>
    for writer in writers { <i class="conum" data-value="4"></i><b>(4)</b>
        writer.await?;
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice what happens with all of the channels once we exit the accept loop:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, we drop the main broker&#8217;s sender.
That way when the readers are done, there&#8217;s no sender for the broker&#8217;s channel, and the chanel closes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Next, the broker exits <code>while let Some(event) = events.next().await</code> loop.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>It&#8217;s crucial that, at this stage, we drop the <code>peers</code> map.
This drops writer&#8217;s senders.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Now we can join all of the writers.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finally, we join the broker, which also guarantees that all the writes have terminated.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_disconnections">Handling Disconnections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Currently, we only ever <em>add</em> new peers to the map.
This is clearly wrong: if a peer closes connection to the chat, we should not try to send any more messages to it.</p>
</div>
<div class="paragraph">
<p>One subtlety with handling disconnection is that we can detect it either in the reader&#8217;s task, or in the writer&#8217;s task.
The most obvious solution here is to just remove the peer from the <code>peers</code> map in both cases, but this would be wrong.
If <em>both</em> read and write fail, we&#8217;ll remove the peer twice, but it can be the case that the peer reconnected between the two failures!
To fix this, we will only remove the peer when the write side finishes.
If the read side finishes we will notify the write side that it should stop as well.
That is, we need to add an ability to signal shutdown for the writer task.</p>
</div>
<div class="paragraph">
<p>One way to approach this is a <code>shutdown: Receiver&lt;()&gt;</code> channel.
There&#8217;s a more minimal solution however, which makes a clever use of RAII.
Closing a channel is a synchronization event, so we don&#8217;t need to send a shutdown message, we can just drop the sender.
This way, we statically guarantee that we issue shutdown exactly once, even if we early return via <code>?</code> or panic.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s add shutdown channel to the <code>client</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">#[derive(Debug)]
enum Void {} <i class="conum" data-value="1"></i><b>(1)</b>

#[derive(Debug)]
enum Event {
    NewPeer {
        name: String,
        stream: Arc&lt;TcpStream&gt;,
        shutdown: Receiver&lt;Void&gt;, <i class="conum" data-value="2"></i><b>(2)</b>
    },
    Message {
        from: String,
        to: Vec&lt;String&gt;,
        msg: String,
    },
}

async fn client(mut broker: Sender&lt;Event&gt;, stream: TcpStream) -&gt; Result&lt;()&gt; {
    // ...

    let (_shutdown_sender, shutdown_receiver) = mpsc::unbounded::&lt;Void&gt;(); <i class="conum" data-value="3"></i><b>(3)</b>
    broker.send(Event::NewPeer {
        name: name.clone(),
        stream: Arc::clone(&amp;stream),
        shutdown: shutdown_receiver,
    }).await.unwrap();

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To enforce that no messages are send along the shutdown channel, we use an uninhabited type.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We pass the shutdown channel to the writer task</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In the reader, we create an <code>_shutdown_sender</code> whose only purpose is to get dropped.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the <code>client_writer</code>, we now need to chose between shutdown and message channels.
We use <code>select</code> macro for this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use futures::select;

async fn client_writer(
    messages: &amp;mut Receiver&lt;String&gt;,
    stream: Arc&lt;TcpStream&gt;,
    mut shutdown: Receiver&lt;Void&gt;, <i class="conum" data-value="1"></i><b>(1)</b>
) -&gt; Result&lt;()&gt; {
    let mut stream = &amp;*stream;
    loop { <i class="conum" data-value="2"></i><b>(2)</b>
        select! {
            msg = messages.next() =&gt; match msg {
                Some(msg) =&gt; stream.write_all(msg.as_bytes()).await?,
                None =&gt; break,
            },
            void = shutdown.next() =&gt; match void {
                Some(void) =&gt; match void {}, <i class="conum" data-value="3"></i><b>(3)</b>
                None =&gt; break,
            }
        }
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We add shutdown channel as an argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Because of <code>select</code>, we can&#8217;t use a <code>while let</code> loop, so we desugar it further into a <code>loop</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In the shutdown case we use <code>match void {}</code> as a statically-checked <code>unreachable!()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another problem is that between the moment we detect disconnection in <code>client_writer</code> and the moment when we actually remove the peer from the <code>peers</code> map, new messages might be pushed into the peer&#8217;s channel.
To not lose these messages completely, we&#8217;ll return the messages channel back to broker.
This also allows us to establish a useful invariant that the message channel strictly outlives the peer in the <code>peers</code> map, and make the broker itself infailable.</p>
</div>
<div class="paragraph">
<p>The final code looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::{
    net::ToSocketAddrs,
    sync::Arc,
    collections::hash_map::{HashMap, Entry},
};

use futures::{
    channel::mpsc,
    SinkExt,
    select,
};

use async_std::{
    io::BufReader,
    prelude::*,
    task,
    net::{TcpListener, TcpStream},
};

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
type Sender&lt;T&gt; = mpsc::UnboundedSender&lt;T&gt;;
type Receiver&lt;T&gt; = mpsc::UnboundedReceiver&lt;T&gt;;

#[derive(Debug)]
enum Void {}

fn main() -&gt; Result&lt;()&gt; {
    task::block_on(server("127.0.0.1:8080"))
}

async fn server(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
    let listener = TcpListener::bind(addr).await?;

    let (broker_sender, broker_receiver) = mpsc::unbounded();
    let broker = task::spawn(broker(broker_receiver));
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!("Accepting from: {}", stream.peer_addr()?);
        spawn_and_log_error(client(broker_sender.clone(), stream));
    }
    drop(broker_sender);
    broker.await;
    Ok(())
}

async fn client(mut broker: Sender&lt;Event&gt;, stream: TcpStream) -&gt; Result&lt;()&gt; {
    let stream = Arc::new(stream);
    let reader = BufReader::new(&amp;*stream);
    let mut lines = reader.lines();

    let name = match lines.next().await {
        None =&gt; Err("peer disconnected immediately")?,
        Some(line) =&gt; line?,
    };
    let (_shutdown_sender, shutdown_receiver) = mpsc::unbounded::&lt;Void&gt;();
    broker.send(Event::NewPeer {
        name: name.clone(),
        stream: Arc::clone(&amp;stream),
        shutdown: shutdown_receiver,
    }).await.unwrap();

    while let Some(line) = lines.next().await {
        let line = line?;
        let (dest, msg) = match line.find(':') {
            None =&gt; continue,
            Some(idx) =&gt; (&amp;line[..idx], line[idx + 1 ..].trim()),
        };
        let dest: Vec&lt;String&gt; = dest.split(',').map(|name| name.trim().to_string()).collect();
        let msg: String = msg.trim().to_string();

        broker.send(Event::Message {
            from: name.clone(),
            to: dest,
            msg,
        }).await.unwrap();
    }

    Ok(())
}

async fn client_writer(
    messages: &amp;mut Receiver&lt;String&gt;,
    stream: Arc&lt;TcpStream&gt;,
    mut shutdown: Receiver&lt;Void&gt;,
) -&gt; Result&lt;()&gt; {
    let mut stream = &amp;*stream;
    loop {
        select! {
            msg = messages.next() =&gt; match msg {
                Some(msg) =&gt; stream.write_all(msg.as_bytes()).await?,
                None =&gt; break,
            },
            void = shutdown.next() =&gt; match void {
                Some(void) =&gt; match void {},
                None =&gt; break,
            }
        }
    }
    Ok(())
}

#[derive(Debug)]
enum Event {
    NewPeer {
        name: String,
        stream: Arc&lt;TcpStream&gt;,
        shutdown: Receiver&lt;Void&gt;,
    },
    Message {
        from: String,
        to: Vec&lt;String&gt;,
        msg: String,
    },
}

async fn broker(mut events: Receiver&lt;Event&gt;) {
    let (disconnect_sender, mut disconnect_receiver) = <i class="conum" data-value="1"></i><b>(1)</b>
        mpsc::unbounded::&lt;(String, Receiver&lt;String&gt;)&gt;();
    let mut peers: HashMap&lt;String, Sender&lt;String&gt;&gt; = HashMap::new();

    loop {
        let event = select! {
            event = events.next() =&gt; match event {
                None =&gt; break, <i class="conum" data-value="2"></i><b>(2)</b>
                Some(event) =&gt; event,
            },
            disconnect = disconnect_receiver.next() =&gt; {
                let (name, _pending_messages) = disconnect.unwrap(); <i class="conum" data-value="3"></i><b>(3)</b>
                assert!(peers.remove(&amp;name).is_some());
                continue;
            },
        };
        match event {
            Event::Message { from, to, msg } =&gt; {
                for addr in to {
                    if let Some(peer) = peers.get_mut(&amp;addr) {
                        peer.send(format!("from {}: {}\n", from, msg)).await
                            .unwrap() <i class="conum" data-value="6"></i><b>(6)</b>
                    }
                }
            }
            Event::NewPeer { name, stream, shutdown } =&gt; {
                match peers.entry(name.clone()) {
                    Entry::Occupied(..) =&gt; (),
                    Entry::Vacant(entry) =&gt; {
                        let (client_sender, mut client_receiver) = mpsc::unbounded();
                        entry.insert(client_sender);
                        let mut disconnect_sender = disconnect_sender.clone();
                        spawn_and_log_error(async move {
                            let res = client_writer(&amp;mut client_receiver, stream, shutdown).await;
                            disconnect_sender.send((name, client_receiver)).await <i class="conum" data-value="4"></i><b>(4)</b>
                                .unwrap();
                            res
                        });
                    }
                }
            }
        }
    }
    drop(peers); <i class="conum" data-value="5"></i><b>(5)</b>
    drop(disconnect_sender); <i class="conum" data-value="6"></i><b>(6)</b>
    while let Some((_name, _pending_messages)) = disconnect_receiver.next().await {
    }
}

fn spawn_and_log_error&lt;F&gt;(fut: F) -&gt; task::JoinHandle&lt;()&gt;
where
    F: Future&lt;Output = Result&lt;()&gt;&gt; + Send + 'static,
{
    task::spawn(async move {
        if let Err(e) = fut.await {
            eprintln!("{}", e)
        }
    })
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In the broker, we create a channel to reap disconnected peers and their undelivered messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The broker&#8217;s main loop exits when the input events channel is exhausted (that is, when all readers exit).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Because broker itself holds a <code>disconnect_sender</code>, we know that the disconnections channel can&#8217;t be fully drained in the main loop.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We send peer&#8217;s name and pending messages to the disconnections channel in both the happy and the not-so-happy path.
Again, we can safely unwrap because broker outlives writers.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We drop <code>peers</code> map to close writers' messages channel and shut down the writers for sure.
It is not strictly necessary in the current setup, where the broker waits for readers' shutdown anyway.
However, if we add a server-initiated shutdown (for example, kbd:[ctrl+c] handling), this will be a way for the broker to shutdown the writers.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Finally, we close and drain the disconnections channel.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_a_client">Implementing a client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s now implement the client for the chat.
Because the protocol is line-based, the implementation is pretty straightforward:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lines read from stdin should be send over the socket.</p>
</li>
<li>
<p>Lines read from the socket should be echoed to stdout.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unlike the server, the client needs only limited concurrency, as it interacts with only a single user.
For this reason, async doesn&#8217;t bring a lot of performance benefits in this case.</p>
</div>
<div class="paragraph">
<p>However, async is still useful for managing concurrency!
Specifically, the client should <em>simultaneously</em> read from stdin and from the socket.
Programming this with threads is cumbersome, especially when implementing clean shutdown.
With async, we can just use the <code>select!</code> macro.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::net::ToSocketAddrs;

use futures::select;

use async_std::{
    prelude::*,
    net::TcpStream,
    task,
    io::{stdin, BufReader},
};

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;


fn main() -&gt; Result&lt;()&gt; {
    task::block_on(try_main("127.0.0.1:8080"))
}

async fn try_main(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
    let stream = TcpStream::connect(addr).await?;
    let (reader, mut writer) = (&amp;stream, &amp;stream); <i class="conum" data-value="1"></i><b>(1)</b>
    let reader = BufReader::new(reader);
    let mut lines_from_server = futures::StreamExt::fuse(reader.lines()); <i class="conum" data-value="2"></i><b>(2)</b>

    let stdin = BufReader::new(stdin());
    let mut lines_from_stdin = futures::StreamExt::fuse(stdin.lines()); <i class="conum" data-value="2"></i><b>(2)</b>
    loop {
        select! { <i class="conum" data-value="3"></i><b>(3)</b>
            line = lines_from_server.next() =&gt; match line {
                Some(line) =&gt; {
                    let line = line?;
                    println!("{}", line);
                },
                None =&gt; break,
            },
            line = lines_from_stdin.next() =&gt; match line {
                Some(line) =&gt; {
                    let line = line?;
                    writer.write_all(line.as_bytes()).await?;
                    writer.write_all(b"\n").await?;
                }
                None =&gt; break,
            }
        }
    }
    Ok(())
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we split <code>TcpStream</code> into read and write halfs: there&#8217;s <code>impl AsyncRead for &amp;'_ TcpStream</code>, just like the one in std.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We crate a stream of lines for both the socket and stdin.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In the main select loop, we print the lines we receive from server and send the lines we read from the console.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-09-02 10:56:37 UTC
</div>
</div>
</body>
</html>